---
name: file-size-limit
description: 强制执行 ≤ 600 LOC 代码行数限制规范，确保文件单一主题、低上下文依赖、可独立理解，便于 LLM 修改和维护。
---

# 文件行数限制规范 (≤ 600 LOC)

本规范确保代码文件保持单一职责、低上下文依赖、可独立理解，便于 LLM 进行修改和维护。

## 何时使用

- 在编写新代码文件时，确保不超过 600 LOC
- 在重构现有代码时，识别需要拆分的大文件
- 在代码审查时，检查文件是否符合规范
- 当文件超过限制时，必须进行拆分，不允许豁免

## 计数口径

* **LOC = 代码行**：不含空行；注释不计入（推荐），但要统一计数方式
* 自动生成文件必须标注 `// GENERATED`，不受此限制

## 600 行标准（按类型分三档）

### A. 允许接近 600（450–600 以内 OK）

仅限这些"单一职责、上下文清晰"的文件：

#### 1. 单窗口/单页面 UI 实现（Qt Widgets/QML 对应的 C++ glue）

* **只做**：控件创建/绑定、信号槽连接、UI 状态刷新、简单输入校验（字段级）
* **禁止**：启动核心、写配置、系统代理设置、订阅下载解析、规则处理

#### 2. 核心进程控制器（QProcess wrapper）

* **只做**：start/stop/restart、参数拼装、stdout/stderr 读取、退出码处理、健康检查、小状态机
* **禁止**：把 UI、配置落盘、系统代理、订阅逻辑塞进来

#### 3. 单平台系统代理设置器（按 OS 拆开后）

* 例如 `platform/windows/ProxySetter.cpp`（只负责 Windows 的设置/恢复/检测）
* **规则**：一个文件只覆盖一个 OS + 一个子域（系统代理），不能混证书/自启动/防火墙

#### 4. 日志 Model / 解析适配器（单一格式）

* 例如 `CoreLogModel.cpp`：把核心输出转成 model + 过滤
* **禁止**：顺便写文件轮转、上传、订阅更新等

> **A 类文件如果超过 600：必须拆，不允许写理由豁免（为了 LLM 友好）**

---

### B. 建议 300–450（超过就优先拆）

这些文件很容易失控，推荐更小：

* `MainWindow.cpp` / `AppController.cpp`
  * 最好控制在 300–450，超过说明 UI 在做"流程编排"了
* `ConfigRepository.cpp`（读写配置）
  * 超过通常是配置结构/迁移/校验混在一起了
* `SystemIntegration` 相关（自启动/证书/权限/端口检测）
  * 每个点一个文件，别集合

---

### C. 必须拆分（哪怕 < 600 也建议拆，≥ 450 基本就拆）

出现任一条就按模块拆：

#### 1. 多主题混杂

* 一个文件里同时有：UI + QProcess 启停 + 配置读写 + 系统代理 + 日志解析（任意两项以上就危险）

#### 2. 巨型分发逻辑

* 大段 `switch(action)` / `if-else` 每个分支几十行（典型：菜单/按钮处理）

#### 3. 跨层依赖

* UI 直接操作配置文件、直接执行系统命令、直接拼核心参数、直接解析订阅

#### 4. 函数过长

* 任一函数 **> 80 行**（LLM 修改时最容易出错，强制拆成小函数/小对象）

---

## 为了"拿给 LLM 改"的额外硬约束（推荐写进规范）

* **单文件只包含一个主要类/组件**（除非 `namespace detail` 下少量 helper）
* **每个函数 ≤ 80 行**；每个函数圈复杂度（大致）别爆炸：分支太多就拆 handler
* **依赖上限**：一个 `.cpp` 直接 `#include` 建议 **≤ 15 个**（超了通常职责过多）
* **禁止"大杂烩工具函数"**：通用 helper 必须进 `util/`，并有单测或最小自检

---

## Qt 包装型代理软件的推荐拆分清单（保证每个文件 < 600）

* `ui/MainWindow.cpp`：纯 UI（300–450）
* `app/AppController.cpp`：UI 动作 -> service（200–400）
* `core/CoreProcessController.cpp`：QProcess 封装（300–600）
* `core/CoreArgsBuilder.cpp`：核心启动参数拼装（100–250）
* `config/ConfigRepository.cpp`：读写（200–450）
* `config/ConfigMigrator.cpp`：迁移（100–300）
* `system/SystemProxyService.cpp`：跨平台门面（150–300）
* `platform/windows/ProxySetter.cpp`、`platform/macos/...`、`platform/linux/...`（各 200–600）
* `log/CoreLogModel.cpp`（200–600）

---

## 执行指令

### 检查文件大小

1. 统计代码行数（不含空行和注释）
2. 检查文件类型，确定应该属于 A/B/C 哪一类
3. 如果超过对应类别限制，必须拆分

### 拆分策略

1. **识别职责**：列出文件包含的所有功能点（如：托盘/启停/系统代理/配置/日志/订阅）
2. **按职责拆分**：每个文件只负责一个主要功能
3. **提取公共逻辑**：通用 helper 放入 `util/` 目录
4. **保持接口清晰**：拆分后的文件之间通过清晰的接口通信

### 重构大文件

当遇到超过限制的文件时：

1. 分析文件包含的功能点列表
2. 按上述标准确定每个功能应该归属的文件
3. 创建新的文件结构，确保每个文件 < 600 LOC
4. 逐步迁移代码，保持功能完整性
5. 更新相关引用和依赖

---

## 示例

如果 `MainWindow.cpp` 包含以下功能：
- UI 控件创建和绑定
- 核心进程启停
- 系统代理设置
- 配置读写
- 日志显示

应该拆分为：
- `ui/MainWindow.cpp`（300-450）：仅 UI 相关
- `core/CoreProcessController.cpp`（300-600）：进程控制
- `system/SystemProxyService.cpp`（150-300）：系统代理
- `config/ConfigRepository.cpp`（200-450）：配置读写
- `log/CoreLogModel.cpp`（200-600）：日志处理
